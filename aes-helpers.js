var scheduleCore = function (input, i) {
    // Core expansion. Given a 4-byte value do some scrambling
    var a;

    // Rotate input 8 bits to the left
    input = circularRotate(input);

    // Apply the S-Box on all 4 bytes
    for (a = 0; a < 4; a++) {
        // forwardSBox expects a hex number, so first convert
        input[a] = forwardSBox(input[a]);
    }

    // On just the first byte, add 2^i to the byte
    input[0] ^= rcon(i);
};

var rcon = function (input) {
    // Calculate the rcon used in key expansion
    var c = 1;

    if (input == 0) {
        return 0;
    }

    while (input != 1) {
        c = gmul(c, 2);
        input--;
    }

    return c;
};

var gmul = function (a, b) {
    // Galois multiplication of 2 8-bit numbers a and b
    var p = 0, // resulting product
        i, high;

    if (a > 256) {
        console.log("Cannot multiply. A is too long.");
        return 0;
    }
    if (b > 256) {
        console.log("Cannot multiply. B is too long.");
        return 0;
    }

    for (i = 0; i < 8; i++) {
        // If the low bit of b is set, XOR the product by the value of a
        if ((b & 1) == 1) {
           p ^= a;
        }

        // Keep track of whether the high bit of a is set
        high = ((a & 128) == 1);

        // Rotate a one bit to the left, discarding the high bit and make low bit 0
        a <<= 1;

        // If the high bit was set, XOR a with the hex number 0x1B
        if (high) {
            a ^= 27;
        }

        // Rotate b one bit to the right, discarding the low bit and make high bit 0
        b >>>= 1;
    }

    return p;
};

var expandKey = function (key) {
    var c, rcon, t = [], i;

    // Start with 1 key of 16 bytes and expand to 11 keys of 16 bytes (= 176 bytes)
    if (key.length != 16) {
        console.log("Cannot expand key. Only " + key.length + " chars.");
        return key;
    }

    // The first 16 bytes of the expanded key are simply the encryption key
    c = 16;

    // The rcon iteration value is set to 1
    rcon = 1;

    // Until we have 176 bytes of the expanded key, generate 16 more bytes of expanded key
    while (c < 176) {
        // Create the first four bytes of expanded key

        // Create a 4-byte temporary variable t, assign the value of the previous 4 bytes in the temporary key to t
        for (i = 0; i < 4; i++) {
            t[i] = key[i + c - 4];
        }

        if (c % 16 == 0) {
            // Perform scheduleCore on t, with rcon iteration value
            scheduleCore(t, rcon);

            // Increment rcon by one
            rcon++;
        }

        // XOR t with the four-byte block, 16 bytes before the new expanded key.
        // This becomes the next four bytes in the expanded key.
        for (i = 0; i < 4; i++) {
            key[c] = key[c - 16] ^ t[i];
            c++;
        }
    }

    var temp = intToHexArray(key);
    for (i = 0; i <= 16; i++) {
        if (i < 10) {
            console.log("Key0" + i + " = " + temp.substr(32*i, 32));
        } else {
            console.log("Key" + i + " = " + temp.substr(32*i, 32));
        }
    }

    if (key.length != 176) {
        console.log("Error in expandKey()");
    }

    return t;
};

var addRoundKey = function (hex1, hex2) {
    return xor(hex1, hex2);
};

var subBytes = function (hex) {
    var index, sub = "";

    if (hex.length != charsPerBlock) {
        console.log("Cannot substitute. Only " + hex.length + " chars.");
        return sub;
    }

    for (index= 0; index < charsPerBlock; index+= 2) {
        sub += forwardSBox(hex.substr(index, 2));
    }

    if (sub.length != charsPerBlock) {
        console.log("Error in subBytes()");
    }

    return sub;
};

var shiftRows = function (hex) {
    var sub = "";

    if (hex.length != charsPerBlock) {
        console.log("Cannot shift rows. Only " + hex.length + " chars.");
        return sub;
    }

    // First row, no shift
    sub = hex.substr(0, 8);

    // Second row, 1 shift left
    sub += hex.substr(10, 6);
    sub += hex.substr(8, 2);

    // Third row, 2 shifts left
    sub += hex.substr(20, 4);
    sub += hex.substr(16, 4);

    // Fourth row, 3 shifts left
    sub += hex.substr(30, 2);
    sub += hex.substr(24, 6);

    if (sub.length != charsPerBlock) {
        console.log("Error in shiftRows()");
    }
    return sub;
};

var mixColumns = function (hex) {
    var sub = "";

    if (hex.length != charsPerBlock) {
        console.log("Cannot mix columns. Only " + hex.length + " chars.");
        return sub;
    }

    if (sub.length != charsPerBlock) {
        console.log("Error in mixColumns()");
    }

    return hex;
};

var forwardSBox = function (int) {
    var s = [
        0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
        0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
        0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
        0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
        0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
        0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
        0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
        0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
        0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
        0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
        0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
        0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
        0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
        0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
        0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
        0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
    ];
    return s[int];
};

var inverseSBox = function (int) {
    var s = [
        0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
        0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
        0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
        0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
        0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
        0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
        0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
        0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
        0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
        0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
        0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
        0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
        0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
        0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
        0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
        0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D
    ];
    return s[int];
};

var xor = function (hex1, hex2) {
    var hex = "", xorInt;

    while (hex1.length >= 2 && hex2.length >= 2) {
        xorInt = parseInt(hex1.substring(0, 2), 16) ^ parseInt(hex2.substring(0, 2), 16);

        if (xorInt >= 16) {
            hex += xorInt.toString(16);
        } else {
            hex += "0" + xorInt.toString(16);
        }

        hex1 = hex1.substring(2, hex1.length);
        hex2 = hex2.substring(2, hex2.length);
    }
    return hex;
};

var circularRotate = function (input) {
    var a, i;

    // An 8-bit (= 1 byte) circular rotate to the left of a 4 byte word (= 8 hex chars)
    if (input.length != 4) {
        console.log("Cannot circular rotate. Word is " + input.length + " chars, instead of 4.");
        console.log("Word to rotate = " + input);
        return input;
    }

    a = input[0];
    for (i = 0; i < 3; i++) {
        input[i] = input[i + 1];
    }
    input[3] = a;

    if (input.length != 4) {
        console.log("Error in circularRotate()");
    }
    return input;
};

var hexToIntArray = function (hexArray) {
    var i, int = [];

    for (i = 0; i < (hexArray.length / 2); i++) {
        int[i] = parseInt(hexArray.substr(i * 2, 2), 16);
    }
    return int;
};

var intToHexArray = function (intArray) {
    var i, t, hex = "";

    for (i = 0; i < intArray.length; i++) {
        t = intArray[i].toString(16);
        if (t.length == 1) {
            hex += '0';
        }
        hex += t;
    }
    return hex;
};



